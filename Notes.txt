React is JS library that is used to create UI.

To write JS in HTML - 

<div id="root">
        
    </div>

    <script>
        const heading = document.createElement("h1");
        heading.innerHTML = "Hello World from JS";

        const root = document.getElementById("root");
        root.appendChild(heading);
    </script>

First react program in HTML - 

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="root"></div>

    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.development.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
    ></script>

    <script>
        const heading = React.createElement("h1", {}, "Hello World from React"); //h1 element inside react. createElement is a core thing of JS

        console.log(heading); //it will return a raect element, a JS object

        const root = ReactDOM.createRoot(document.getElementById("root")); //Creating a root and rendering inside it is a work of reactDOM

        root.render(heading); //we are rendering the root, this is converting the React element into H1 tag
    </script>
  </body>
</html>

createElement takes 3 parameters (tag, Attributes to tag, "what we want to pass in the tag")
In the last parameters we can pass multiple children but with a help of array.
Heading - It is a React h1 element, It is a JS object

Creating Nested structure and sibling inside react
/*
<div id = "parent">
    <div id = "child">
        <h1>I am H1 nested tag</h1>
        <h2>I am H1 nested tag</h2>
    </div>
</div>

creating this above nested thing in JS
*/

const parent = React.createElement(
  "div",
  { id: "parent" },
  React.createElement("div", { id: "child" }, [
    React.createElement("h1", {}, "I am H1 nested tag"),
    React.createElement("h2", {}, "I am H2 nested tag"),
  ])
);

console.log(parent);

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(parent);

reactElement(object) => HTML(Browser Understands) by .render

/*
<div id = "parent">
    <div id = "child">
        <h1>I am H1 nested tag</h1>
        <h2>I am H1 nested tag</h2>
    </div>
    <div id = "child2">
        <h1>I am H1 nested tag</h1>
        <h2>I am H1 nested tag</h2>
    </div>
</div>

creating this above nested thing in JS
*/

const parent = React.createElement("div", { id: "parent" }, [
  React.createElement("div", { id: "child" }, [
    React.createElement("h1", {}, "I am H1 nested tag"),
    React.createElement("h2", {}, "I am H2 nested tag"),
  ]),
  React.createElement("div", { id: "child2" }, [
    React.createElement("h1", {}, "I am H1 nested tag of child2"),
    React.createElement("h2", {}, "I am H2 nested tag of child2"),
  ]),
]);

console.log(parent);

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(parent);

To avoid this type of structures we use JSX, Which will make things easy

In the HTML file
<div id = "root"></div>

If anything is present inside the root it will be replaced by render giving the control to React.
It will be replaced not appended.

Beauty of React - 
Order of Files matters.
We can define where will our react code will work.

EP2 Notes - 

NPM is not node package manager, globally it is used as abbreviation

Package.json is the configuration file for npm.

npm is a package manager that manages the packages that we install in our system.
Sometime packages are know as dependencies.

The most important package in our product is a bundler.
What is a bundler - Bundler bundles/packages our app properly so that it can be pushed into production. 
Ex : Webpack, Parcel

There are 2 types of dependencies an app can have
Dev dependencies - These are the packages that are only needed for development/testing purposes.
Normal dependencies - these are the packages that are necessary for the application to run in its production environment

To install dev dependencies - npm install -D <package-name>

Installing parcel bundler - npm install -D parcel
"devDependencies": {
    "parcel": "^2.12.0"
  }

What is "^"? - It is Carat, Suppose our dependency got a "minor version update" then it will do it automatically. It is safe and recommended like 2.12.0 -> 2.12.1
What is "~"? - It is tilde, Suppose our dependency got a "major version update" then it will do it automatically. like 2.9.9 -> 3.0.0

File -> package-lock.json 
It keeps the track of exact version of dependencies that is being installed. It keeps the record of each and every exact version of the package/dependency. It keeps the record of exact version so that when the code is pushed into production it don't break.

Folder -> node_modules 
This contains the data of the packages that are needed by our project. It acts like a database

Transitive dependency - When a package have another package as a dependency and that package have another package as dependency it is then know as Transitive dependency.

Every package have its own dependencies, devDependencies and package.json files.

We shouldn't push node_modules to production/github, because
We always need to push package.json, package-lock.json to production because it maintains the record of our dependencies that were used in our app
If we have package.json, package-lock.json then we can regenerate node_modules Folder by "npm install".
Whatever we can regenerate dont push it to production, we only need to push essential files and folders.

Igniting our app - npx parcel index.html(source file)

What is npx? - It means executing the package that we have installed using npm

CDN links are not a good way to bring react in our project, because making network calls multiple time is a costly operation we should call form node_modules and after every version upgrades pf react we need to update the links manually.

<script type="module" src="./App.js"></script>
we need to tell the browser that it is not normal browser script it is a module because @parcel/transformer-js: Browser scripts cannot have imports or exports.

Parcel uses :
- Dev Build
- Local Server
- HMR : Hot Model Replacement, It is when we save our file the changes that we made in our file, the changes immediately reflects on browser
- File watching algorithm - written in c++ , it tracks each and every changes made in our project
- Faster builds because of Parcel cache
- Image Optimization
- Minifiaction of file while creating production projects
- Bundling
- compress
- Consistent Hashing 
- Code Splitting
- Differential Bundling - It gives the support of older browser
- Diagnostic - beautiful errors in terminal 
- Error handling
- host apps on https
- Tree Shaking Algorithm - will remove unused code
- Different dev and production bundles

Production Build our App - npx parcel build index.html(source file)
When we prod build we will run into an error that is in package.json file that is "main" : App.js basically while we are executing parcel we already tell parcel about our entry point we dont need to sepcify that again.

Folder -> dist : It keeps the files that when we exec npx parcel index.html it creates a dev build and host that to port 1234. Those dev build files are kept in dist folder.

EP3 Notes -

JSX :
- It is just a syntax
- JSX is not HTML inside JS
- It is a HTML like syntax in JS
- JSX is Different, React is Different
- It can be nested also
- We can inject JS expressions inside JSX within {JS Expressions}
- JSX prevents cross-site scripting, It means if any api is passing malicious data and that is injected in our jsx then jsx will sanitize it 


JSX => Babel Transpiles it => React.createElement => object => HTMLElement(render)
const jsxHeading = <h1 id = "heading">Namaste React using JSXðŸš€</h1>

This above code is not pure JS, JS engines doesn't understand it and by our browser
These JSX codes are transpiled before it reaches the JS engine so that browsers can understand it. It is managed my parcel and transpiled by Babel

If we write JSX in multiple lines we need to use (jsx code) because babel need to know where is our jsx starting and ending.

import React from "react";
import ReactDOM from "react-dom/client";

//Reacr.createElement => object => renderToDOM => HTMLElement

// const heading = React.createElement(
//   "h1",
//   { id: "heading" },
//   "Namaste-React ðŸš€"
// );

//JSX
//JSX => React.createElement => object => HTMLElement(render)
const jsxHeading = (
  <h1 className="head" tabIndex="5">
    Namaste React using JSXðŸš€
  </h1>
);

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(jsxHeading);


React Components - 
- Everything is a component in React

Two types of Components in React :
- Class Based Component : OLD 
- Funcitonal Component : NEW 

What is React Funcitonal Component - It is a normal JS Function which return some jsx

const HeadingComponent = () => {
  return <h1 className="heading">Namaste React Functional Component</h1>;
};

const HeadingComponent2 = () => (
    <h1 className="heading">Namaste React Functional Component2</h1>
);

Both of the above codes are same

root.render(<ComponentName />); //we can render React Component like this

What is component composition - Composing two components inside one another is called component composition
For Ex : 
const Title = () => (
  <h1> Hi, I'm Title </h1>;
);

Const Heading = () => (
  <div>
    <Title />
    <h1>Hi, I'm Heading</h1>
  </div>
);

How to put react element inside react component ?
const title = (
  <h1>Namast React using JSX</h1>
);

Const Heading = () => (
  <div>
    {title}
    <h1>Hi, I'm Heading</h1>
  </div>
);

How to put react element inside react element ?
const elem = <p> Hi </p>;

const title = <h1> {elem} Namaste using JSX</h1>;

const HeadingComponent = () => (
  <div>
    {title}
    <h1 className="heading">Namaste React Functional Component</h1>
  </div>
);

How to put react component inside react component ?

Why my code is readable? - Because it uses JSX


EP4 Notes - 

What are Props? - Passing a prop to a component is same as passing a argument to a function.
Ex : 
<RestaurantCard resName = "ABC" cuisine = "Asian" />
<RestaurantCard resName = "XYZ" cuisine = "Korean" />

Props are used to avoid hardcoding

Config Driven UI - Controlling your UI using data that is given by the database. It is used because suppose there is Swiggy a food delivery app that operates at pan India level but the developers will not make UI for every Different city or regions they make a single UI and it is controlled by the data that is coming from the database.

Whenever we use "map" function we should always use "key" because it optimizes the renders in react app.
Never use indexes as key.
Try to use unique IDs as key if possible if not use indexes but never forget to use keys while using map function.

Optional chaining - 
The ?. is known as the optional chaining operator in JavaScript. It is used to access properties of an object without causing an error if the property does not exist or if the object itself is null or undefined.

In your example resData?.info, if resData is null or undefined, the expression will short-circuit and return undefined. This means that if resData is null or undefined, trying to access the info property won't throw an error. If resData is an object with an info property, its value will be returned.

This feature is particularly useful when dealing with nested objects or accessing properties that might not exist in all cases, as it helps prevent "Cannot read property 'x' of undefined" errors. It's part of ECMAScript 2020 and is supported in modern JavaScript environments.

EP5 Notes - 

There are 2 types of export and import - 

- default export/import 
    export default <component_name>;
    import <component_name> from 'file_path';

- named export/import used to export/import multiple things from one js file
    export const <component_name>;
    import {component_name} from 'file_path';

React Hooks - It is a normal JS function, It comes with some extra super powers that are given by react

Types of hooks :
- useState() -> superpowerful state variables in react 
- useEffect() -> 

Whenever a state variable changes react will re render the component. React triggers a Reconciliation cycle.

React uses Reconciliation Algorithm(React Fiber) 
Reconciliation Algorithm - When somethinf changes on the UI.
In React 16, the Diff Algo came out to update the DOM

Virtual DOM - It is a representation of an Actual DOM

Diff Algorithm - It finds out the difference between the previous virtual DOM and the updated virtual DOM. And after it find out the diff it keeps updating the actual DOM on every render.

EP6 Notes - 

Monolith and Micro-service Architecture

useEffect Hook - 
- It takes two argument 
  - callback function
  - dependency array: It changes the behaviour of the callback function of useEffect hook
  - The callback function will be executed after it has been rendered once
  - 
- If no dependecy array callback function is called on every render
- If there is an empty dependency array[], useEffect is called on intial render(just once)
- If there is something as dependency in the dependency array then useEffect will be called whenever the dependency changes

EP7 Notes - 

- Never call the useState hook outside the component.
- call hooks on the top of the component.
- Never create hooks in if/else or inside conditions it will cause inconsistency.

There are 2 types of routing in web application:
- Client Side Routing: When the web app is loaded the component also gets loaded with that when we change pages the components only gets replaced no network call are made. This is why react is single page application.
- Server Side Routing: when we do a fetch call to get some pages and its returned by servers. It makes network calls.

React Routes : React-router-dom
- createBrowserRouter: It takes list and have objects inside list with object contents as "path", "element", "children"
const router = createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    loader: rootLoader,
    children: [
      {
        path: "team",
        element: <Team />,
        loader: teamLoader,
      },
    ],
  },
]);

- Router Provider: All data router objects are passed to this component to render your app and enable the rest of the data APIs.
root.render(<RouterProvider router={appRouter} />);

React Router Components:

-Link: Use this in place of anchor tag like <Link to = "/">Home</Limk
- Outlet: An <Outlet> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or nothing if there is no index route.

React Router Hooks: 

- useRouteError: Inside of an errorElement, this hook returns anything thrown during an action, loader, or rendering. Note that thrown responses have special treatment, see isRouteErrorResponse for more information.
like err.status , err.statusText, etc.

Dynamic Routing :
- path: "/restaurant/:resId"
the :resId is the Dynamic route that will be changed for every other restaurant.

EP8 Notes - 

Classbased Components : It has class which extends React.component which have render method and that returns some piece of JSX.

class <class_name> extends React.component{
  constructor(props){
    super(props);

  }
  render(){
    //it returns jsx
    return(
      //jsx code
    )
  }
}

export default <class_name>;

with help of React.component React gets to know that it is a class based Component

render() - with help of this the jsx written inside it is displayed on the web

we need to export it.

this.setState({object}) - it helps to update state variables. 


Life Cycle of React Classbased Component: 
When the Class is mounted on to the DOM, The instance of the class is created and the constructor is called then the render method is called and after that componentDidMount is called

Instance of Class created -> Constructor is called -> Render method is called -> componentDidMount method is called

Parent Constructor -> Parent Render -> (All the Child Components gets exec) Child Constructor -> Child Render -> Child componentDidMount -> Parent componentDidMount

Why componentDidMount() method is used? - There are somthings that we do once the component is mounted successfully. It is used to make API calls.

Why API calls are made inside componentDidMount() method? - Because Once the instance of the class is created the constructor is called then the component is rendered and after that the API call is made so that the data gets filled inside the rendered component.

componentDidUpdate() method - It is called at last when the API call is made and the component has been re-rendered using the API data fetched.


Life Cycle of React Classbased component if there is more than one children: 

- It works in two phases namely "Render Phase" where to optimize the code react batches all the constructors and render methods of all the children and render them and "Commit Phase" here are the Updation to the DOM like componentDidMount method is happened in batch for all the children as DOM manipulation is very expensive.

- Example: 
class about extends React.component{
  constructor(props){
    super(props);
    console.loG("Parent Constructor");
  }

  componentDidMount(){
    console.log("Parent componentDidMount");
  }

  render(){
    console.loG("Parent Render");
    <Child name = {"Child1"} />
    <Child name = {"Child2"} />
  }
}

class Child extends React.component{
  constructor(props){
    super(props);
    console.loG(this.props.name +  "Constructor");
  }

  componentDidMount(){
    console.log(this.props.name + "componentDidMount");
  }

  render(){
    console.loG(this.props.name + "Render");
  }
}

- Output: 

Parent Constructor
Parent Render

  //Here react batches the children components in Render Phase to optimize
  Child1 Constructor
  Child1 Render

  Child2 Constructor
  Child2 Render

  //Here react batches the DOM updates of the children components in Commit Phase as because DOM manipulation is expensive
  Child1 componentDidMount
  Child2 componentDidMount

Parent componentDidMount

React Life Cycle when a API CALL is made:
 * ---MOUNTING---
 * Constructor (Local state vars are created and given dummy data)
 * Render (It is rendered on the web using dummy data)
 *    <HTML> (with dummy data)
 * componentdidMount()
 *    API CALL is made
 *    this.setState() (local state var is upated with the Json Data fetched from API)
 * 
 * ---UPDATING---
 * Render(with API Data) the component is re-rendered as the local state var is updated
 * <HTML> (with API Data)
 * componentDidUpdate()
 * 
 * ---UNMOUNTING---
 * componentWillUnmount()
 * when we move to another page the data that was displayed in the UI gets unmounted resulting in triggering this method

didn't do the last 45 mins live session rec in EP8


